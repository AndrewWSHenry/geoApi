<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>proj.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Tutorials</h3><ul><li><a href="tutorial-developer-guide.html">developer-guide</a></li><li><a href="tutorial-getting_started.html">getting_started</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addHilight">addHilight</a></li><li><a href="global.html#addPin">addPin</a></li><li><a href="global.html#allComb">allComb</a></li><li><a href="global.html#allocateLayersToSections">allocateLayersToSections</a></li><li><a href="global.html#arrayBufferToString">arrayBufferToString</a></li><li><a href="global.html#assignIds">assignIds</a></li><li><a href="global.html#assignLayerSplits">assignLayerSplits</a></li><li><a href="global.html#checkProj">checkProj</a></li><li><a href="global.html#clearHilight">clearHilight</a></li><li><a href="global.html#clipExtentCoords">clipExtentCoords</a></li><li><a href="global.html#cloneLayerGraphic">cloneLayerGraphic</a></li><li><a href="global.html#convertImageToCanvas">convertImageToCanvas</a></li><li><a href="global.html#convertImagetoDataURL">convertImagetoDataURL</a></li><li><a href="global.html#crawlLayerInfos">crawlLayerInfos</a></li><li><a href="global.html#createAttribSet">createAttribSet</a></li><li><a href="global.html#csvPeek">csvPeek</a></li><li><a href="global.html#enforceBoundary">enforceBoundary</a></li><li><a href="global.html#enhanceRenderer">enhanceRenderer</a></li><li><a href="global.html#extractFields">extractFields</a></li><li><a href="global.html#featureTypeToRenderer">featureTypeToRenderer</a></li><li><a href="global.html#findClosestLOD">findClosestLOD</a></li><li><a href="global.html#findOptimalSplit">findOptimalSplit</a></li><li><a href="global.html#generateLocalCanvas">generateLocalCanvas</a></li><li><a href="global.html#generatePlaceholderSymbology">generatePlaceholderSymbology</a></li><li><a href="global.html#generateServerImage">generateServerImage</a></li><li><a href="global.html#generateUUID">generateUUID</a></li><li><a href="global.html#generateWMSSymbology">generateWMSSymbology</a></li><li><a href="global.html#geomToGraphic">geomToGraphic</a></li><li><a href="global.html#getExtentFromJson">getExtentFromJson</a></li><li><a href="global.html#getGraphicIcon">getGraphicIcon</a></li><li><a href="global.html#getGraphicSymbol">getGraphicSymbol</a></li><li><a href="global.html#getLayerType">getLayerType</a></li><li><a href="global.html#getLegendUrls">getLegendUrls</a></li><li><a href="global.html#getNorthArrowAngle">getNorthArrowAngle</a></li><li><a href="global.html#getScaleRatio">getScaleRatio</a></li><li><a href="global.html#getUnboundGraphics">getUnboundGraphics</a></li><li><a href="global.html#getZoomLevel">getZoomLevel</a></li><li><a href="global.html#guessCSVfields">guessCSVfields</a></li><li><a href="global.html#hideLayers">hideLayers</a></li><li><a href="global.html">isSpatialRefEqual</a></li><li><a href="global.html#loadDataBatch">loadDataBatch</a></li><li><a href="global.html#loadFeatureAttribs">loadFeatureAttribs</a></li><li><a href="global.html#localProjectExtent">localProjectExtent</a></li><li><a href="global.html#localProjectGeometry">localProjectGeometry</a></li><li><a href="global.html#localProjectPoint">localProjectPoint</a></li><li><a href="global.html#makeBasemaps">makeBasemaps</a></li><li><a href="global.html#makeBoundingBox">makeBoundingBox</a></li><li><a href="global.html#makeGeoJsonLayer">makeGeoJsonLayer</a></li><li><a href="global.html#makeHilightLayer">makeHilightLayer</a></li><li><a href="global.html#makeLegend">makeLegend</a></li><li><a href="global.html#mapDefault">mapDefault</a></li><li><a href="global.html#newLayerBundle">newLayerBundle</a></li><li><a href="global.html#newLayerPackage">newLayerPackage</a></li><li><a href="global.html#normalizeProj">normalizeProj</a></li><li><a href="global.html#packLayersIntoExactSections">packLayersIntoExactSections</a></li><li><a href="global.html#packLayersIntoOptimalSections">packLayersIntoOptimalSections</a></li><li><a href="global.html#predictLayerUrl">predictLayerUrl</a></li><li><a href="global.html#processDynamicLayer">processDynamicLayer</a></li><li><a href="global.html#processFeatureLayer">processFeatureLayer</a></li><li><a href="global.html#projectGeojson">projectGeojson</a></li><li><a href="global.html#projectionLookup">projectionLookup</a></li><li><a href="global.html#resizeSVGElement">resizeSVGElement</a></li><li><a href="global.html#scrapeListRenderer">scrapeListRenderer</a></li><li><a href="global.html#searchRenderer">searchRenderer</a></li><li><a href="global.html#serverLayerIdentify">serverLayerIdentify</a></li><li><a href="global.html#serviceType">serviceType</a></li><li><a href="global.html#setProxy">setProxy</a></li><li><a href="global.html#setupMap">setupMap</a></li><li><a href="global.html#showLayers">showLayers</a></li><li><a href="global.html#splitLayer">splitLayer</a></li><li><a href="global.html#svgDrawImage">svgDrawImage</a></li><li><a href="global.html#symbolToLegend">symbolToLegend</a></li><li><a href="global.html#validateCSV">validateCSV</a></li><li><a href="global.html#validateFile">validateFile</a></li><li><a href="global.html#validateGeoJson">validateGeoJson</a></li><li><a href="global.html#validateLatLong">validateLatLong</a></li><li><a href="global.html#wrapEvents">wrapEvents</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">proj.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
const proj4 = require('proj4');
const terraformer = require('terraformer');
const teraProj = require('terraformer-proj4js');

/**
 * Reproject a GeoJSON object in place.  This is a wrapper around terraformer-proj4js.
 * @param {Object} geojson the GeoJSON to be reprojected, this will be modified in place
 * @param {String|Number} outputSpatialReference the target spatial reference,
 * 'EPSG:4326' is used by default; if a number is suppied it will be used as an EPSG code
 * @param {String|Number} inputSpatialReference same rules as outputSpatialReference if suppied
 * if missing it will attempt to find it encoded in the GeoJSON
 */
function projectGeojson(geojson, outputSpatialReference, inputSpatialReference) {
    const converter = teraProj(terraformer, proj4);
    converter(geojson, outputSpatialReference, inputSpatialReference);
}

/**
 * Convert a projection to an string that is compatible with proj4.  If it is an ESRI SpatialReference or an integer it will be converted.
 * @param {Object|Integer|String} proj an ESRI SpatialReference, integer or string.  Strings will be unchanged and unchecked,
 * ints and SpatialReference objects will be converted.
 * @return {String} A string in the form EPSG:####
 * @private
 */
function normalizeProj(proj) {
    if (typeof proj === 'object') {
        if (proj.wkid) {
            return 'EPSG:' + proj.wkid;
        } else if (proj.wkt) {
            return proj.wkt;
        }
    } else if (typeof proj === 'number') {
        return 'EPSG:' + proj;
    } else if (typeof proj === 'string') {
        return proj;
    }
    throw new Error('Bad argument type, please provide a string, integer or SpatialReference object.');
}

/**
 * Project a single point.
 * @param {Object|Integer|String} srcProj the spatial reference of the point (as ESRI SpatialReference, integer WKID or an EPSG string)
 * @param {Object|Integer|String} destProj the spatial reference of the result (as ESRI SpatialReference, integer WKID or an EPSG string)
 * @param {Array|Object} point a 2d array or object with {x,y} props containing the coordinates to Reproject
 * @return {Array|Object} a 2d array or object containing the projected point
 */
function localProjectPoint(srcProj, destProj, point) {
    return proj4(normalizeProj(srcProj), normalizeProj(destProj), point);
}

/**
 * Project a single point.
 * @param {Object|Integer|String} destProj the spatial reference of the result (as ESRI SpatialReference, integer WKID or an EPSG string)
 * @param {Object} geometry an object conforming to ESRI Geometry object standards containing the coordinates to Reproject
 * @return {Object} an object conforming to ESRI Geomtery object standards containing the input geometry in the destination projection
 */
function localProjectGeometry(destProj, geometry) {
    // FIXME we seem to be really dependant on wkid. ideally enhance to handle all SR types

    // HACK >:'(
    // terraformer has this undesired behavior where, if your input geometry is in WKID 102100, it will magically
    // project all your co-ordinates to lat/long when converting between ESRI and GeoJSON formats.
    // to stop it from ruining us, we temporarily set the spatial reference to nonsense so it will leave it alone
    const realSR = geometry.spatialReference;
    geometry.spatialReference = { wkid: 8888 }; // nonsense!
    const grGeoJ = terraformer.ArcGIS.parse(geometry, { sr: 8888 });
    geometry.spatialReference = realSR;

    // project json
    projectGeojson(grGeoJ, normalizeProj(destProj), normalizeProj(realSR));

    // back to esri format
    const grEsri = terraformer.ArcGIS.convert(grGeoJ);

    // doing this because .convert likes to attach a lat/long spatial reference for fun.
    grEsri.spatialReference = destProj;

    return grEsri;
}

/**
 * Reproject an EsriExtent object on the client.  Does not require network
 * traffic, but may not handle conversion between projection types as well.
 * Internally it tests 8 points along each edge and takes the max extent
 * of the result.
 *
 * @param {EsriExtent} extent to reproject
 * @param {Object} sr is the target spatial reference (if a number it
 *                 will be treated as a WKID)
 * @returns {Object} an extent as an unstructured object
 */
function localProjectExtent(extent, sr) {

    // interpolates two points by splitting the line in half recursively
    function interpolate(p0, p1, steps) {
        if (steps === 0) { return [p0, p1]; }

        let mid = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
        if (steps === 1) {
            return [p0, mid, p1];
        }
        if (steps > 1) {
            let i0 = interpolate(p0, mid, steps - 1);
            let i1 = interpolate(mid, p1, steps - 1);
            return i0.concat(i1.slice(1));
        }
    }

    const points = [[extent.xmin, extent.ymin], [extent.xmax, extent.ymin],
                    [extent.xmax, extent.ymax], [extent.xmin, extent.ymax],
                    [extent.xmin, extent.ymin]];
    let interpolatedPoly = [];
    let srcProj;

    // interpolate each edge by splitting it in half 3 times (since lines are not guaranteed to project to lines we need to consider
    // max / min points in the middle of line segments)
    [0, 1, 2, 3]
        .map(i => interpolate(points[i], points[i + 1], 3).slice(1))
        .forEach(seg => interpolatedPoly = interpolatedPoly.concat(seg));

    // find the source extent (either from wkid or wkt)
    if (extent.spatialReference.wkid) {
        srcProj = 'EPSG:' + extent.spatialReference.wkid;
    } else if (extent.spatialReference.wkt) {
        srcProj = extent.spatialReference.wkt;
    } else {
        throw new Error('No WKT or WKID specified on extent.spatialReference');
    }

    // find the destination extent
    let destProj = normalizeProj(sr);

    if (extent.spatialReference.wkid &amp;&amp; !proj4.defs(srcProj)) {
        throw new Error('Source projection WKID not recognized by proj4 library');
    }
    const projConvert = proj4(srcProj, destProj);
    const transformed = interpolatedPoly.map(x => projConvert.forward(x));

    const xvals = transformed.map(x => x[0]);
    const yvals = transformed.map(x => x[1]);

    const x0 = Math.min.apply(null, xvals);
    const x1 = Math.max.apply(null, xvals);

    const y0 = Math.min.apply(null, yvals);
    const y1 = Math.max.apply(null, yvals);

    return { x0, y0, x1, y1, sr };
}

/**
 * Check whether or not a spatialReference is supported by proj4 library.
 *
 * @param {Object} spatialReference to be checked to see if it's supported by proj4
 * @param {Function} epsgLookup an optional lookup function for EPSG codes which are not loaded
 * in the proj4 definitions, the function should take a numeric EPSG code and return a Promise
 * resolving with a proj4 style definition string
 * @returns {Object} with the structure {
 *  foundProj: (bool) indicates if the projection was found,
 *  message: (string) provides a reason why the projection was not found,
 *  lookupPromise: (Promise) an optional promise resolving with true or false if a lookup function was provided and had to be invoked
 * }
 */
function checkProj(spatialReference, epsgLookup) {
    let srcProj;

    // find the source extent (either from wkid or wkt)
    if (spatialReference.wkid) {
        srcProj = 'EPSG:' + spatialReference.wkid;
    } else if (spatialReference.wkt) {
        srcProj = spatialReference.wkt;
    } else {
        return {
            foundProj: false,
            message: 'No WKT or WKID specified on extent.spatialReference'
        };
    }

    if (spatialReference.wkid &amp;&amp; !proj4.defs(srcProj)) {
        if (epsgLookup) {
            return {
                foundProj: false,
                message: 'Attempting to lookup WKID',
                lookupPromise: epsgLookup(spatialReference.wkid).then(def => {
                    if (def === null) {
                        return false;
                    }
                    proj4.defs(srcProj, def);
                    return true;
                })
            };
        }
        return {
            foundProj: false,
            message: 'Source projection in WKID and not recognized by proj4 library'
        };
    }

    return {
        foundProj: true,
        message: 'Source projection OK.'
    };
}

function projectEsriExtentBuilder(esriBundle) {
    return (extent, sr) => {
        const p = localProjectExtent(extent, sr);
        return new esriBundle.Extent(p.x0, p.y0, p.x1, p.y1, p.sr);
    };
}

function esriServiceBuilder(esriBundle) {
    /**
     * Reproject an esri geometry object on the server. Requires network traffic
     * to esri's Geometry Service, but may be slower than proj4 conversion.
     * Internally it tests 1 point and reprojects it to another spatial reference.
     *
     * @param {url} url for the ESRI Geometry Service
     * @param {geometries} geometries to be projected
     * @param {sr} sr is the target spatial reference
     * @returns {Promise} promise to return reprojected geometries
     */
    return (url, geometries, sr) => {
        return new Promise(
            (resolve, reject) => {
                const params = new esriBundle.ProjectParameters();

                // connect to esri server
                const gsvc = new esriBundle.GeometryService(url);

                params.geometries = geometries;
                params.outSR = sr;

                // call project function from esri server to do conversion
                gsvc.project(params,
                    projectedExtents => {
                        resolve(projectedExtents);
                    }, error => {
                        reject(error);
                    });
            });
    };
}

/**
* Checks if two spatial reference objects are equivalent.  Handles both wkid and wkt definitions.
*
* @method isSpatialRefEqual
* @static
* @param {type} sr1 Esri Spatial Reference First to compare
* @param {type} sr2 Esri Spatial Reference Second to compare
* @return {Boolean} true if the two spatial references are equivalent.  False otherwise.
*/
function isSpatialRefEqual(sr1, sr2) {
    if ((sr1.wkid) &amp;&amp; (sr2.wkid)) {
        // both SRs have wkids
        return sr1.wkid === sr2.wkid;
    } else if ((sr1.wkt) &amp;&amp; (sr2.wkt)) {
        // both SRs have wkt's
        return sr1.wkt === sr2.wkt;
    } else {
        // not enough info provided or mismatch between wkid and wkt.
        return false;
    }
}

module.exports = function (esriBundle) {
    // TODO: Move Point and SpatialReference to its own (geometry) module

    // TODO consider moving this elsewhere.  state is bad, but these are common, and we have no service for esri defs
    proj4.defs('EPSG:3978', '+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 ' +
        '+lon_0=-95 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
    proj4.defs('EPSG:3979', '+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 +lon_0=-95 ' +
        '+x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
    proj4.defs('EPSG:54004', '+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 ' +
        '+datum=WGS84 +units=m +no_defs');
    proj4.defs('EPSG:102100', proj4.defs('EPSG:3857'));

    return {
        addProjection: proj4.defs, // straight passthrough at the moment, maybe add arg checking (two args)?
        checkProj,
        getProjection: proj4.defs, // straight passthrough at the moment, maybe add arg checking (one arg)?
        esriServerProject: esriServiceBuilder(esriBundle),
        Graphic: esriBundle.Graphic,
        graphicsUtils: esriBundle.graphicsUtils,
        isSpatialRefEqual,
        localProjectExtent,
        localProjectPoint,
        localProjectGeometry,
        projectGeojson,
        Point: esriBundle.Point,
        projectEsriExtent: projectEsriExtentBuilder(esriBundle),
        SpatialReference: esriBundle.SpatialReference
    };
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Fri Dec 02 2016 15:06:01 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
